use bevy::prelude::*;
use bevy::reflect::TypeUuid;
use bevy::render::render_graph::RenderGraph;
use bevy::render::render_resource::*;
use bevy::render::renderer::RenderDevice;
use bevy::render::texture::BevyDefault;
use bevy::render::view::{ViewTarget, ViewUniform};
use bevy_app::prelude::*;
use bevy_ecs::prelude::World;
use bevy_render::render_graph::{RenderGraph, Node, RenderGraphContext, NodeRunError};
use bevy_render::renderer::RenderContext;
use bevy_core_pipeline::{core_2d::Camera2d, core_3d::Camera3d};

pub struct SkyboxPlugin;

impl Plugin for SkyboxPlugin {
    fn build(&self, app: &mut App) {
        app.add_asset::<SkyboxMaterial>()
            .add_system_to_stage(
                CoreStage::PostUpdate,
                asset_shader_defs_system::<SkyboxMaterial>.system(),
            )
            .init_resource::<SkyboxTextureConversion>()
            .add_system(convert_skyboxes.system());
        add_skybox_graph(app.world_mut());

        // add default SkyboxMaterial
        let mut materials = app
            .world_mut()
            .get_resource_mut::<Assets<SkyboxMaterial>>()
            .unwrap();
        materials.set_untracked(
            Handle::<SkyboxMaterial>::default(),
            SkyboxMaterial {
                color: Color::PINK,
                ..Default::default()
            },
        );
    }
}

#[derive(Bundle)]
pub struct SkyboxBundle {
    pub material: Handle<SkyboxMaterial>,
    pub visibility: Visibility,
}

impl SkyboxBundle {
    /// Convenience constructor for [`SkyboxBundle`]. Sets the material and uses defaults for
    /// everything else. In most use cases you should only need to set the material.
    pub fn new(material: Handle<SkyboxMaterial>) -> Self {
        Self {
            material,
            ..Default::default()
        }
    }
}

impl Default for SkyboxBundle {
    fn default() -> Self {
        Self {
            material: Default::default(),
            visibility: Visibility::VISIBLE,
        }
    }
}

/// Material for a Skybox. Consists of a base color and an optional 6-sided array-texture.
///
/// When rendering, the color from the texure is multiplied by the base color. This can be used to
/// tint the skybox. When creating a new material, the default color is [`Color::WHITE`] which will
/// have no effect on the texture color.
///
/// It is also possible to use a skybox texture with only a [`Color`]. One reason you might want to
/// do this is that (at time of writing) Bevy does not seem to antialias against the window
/// [`ClearColor`] properly, instead antialiasing with white for objects that have not other 3d
/// object behind them. This leads to white borders around antialiased object that overlap the
/// window clear color. To avoid this, you could spawn a skybox using only a color. Since the skybox
/// is a 3d rendered object, antialiasing against it works properly.
///
/// Skyboxes should generally be spawned using [`SkyboxBundle`], and you can see that type for info
/// on what components are used with this material.
#[derive(RenderResources, Debug, ShaderDefs, TypeUuid)]
// UUID5 generated by first creating a URL-namespaced UUID5 for
// "https://github.com/google/bevy_skybox_cubemap" (24291f52-ea01-574a-b6ae-3d8182f6086b) then using
// that as the namespace with `bevy_skybox_cubemap::SkyboxMaterial` as the name.
#[uuid = "fca7708e-57bb-5a81-977f-95b0e5202de0"]
pub struct SkyboxMaterial {
    /// Base color of the skybox. Multiplied with the color from the texture if a texture is
    /// supplied, otherwise used by itself as the skybox color.
    pub color: Color,
    /// Texture to use for the skybox. This must be a an aray texture with 6 layers which are all
    /// square and the same size. See [the crate overview](crate) for details on the required layer
    /// order and how to get a texture in this format.
    #[shader_def]
    pub texture: Option<Handle<Texture>>,
}

impl SkyboxMaterial {
    /// Creates a `SkyboxMaterial` with just a texture. The color will be set to [`Color::WHITE`] to
    /// avoid tinting the texture.
    pub fn from_texture(texture: Handle<Texture>) -> Self {
        Self {
            texture: Some(texture),
            ..Default::default()
        }
    }

    pub fn from_color(color: Color) -> Self {
        Self {
            color,
            ..Default::default()
        }
    }
}

impl Default for SkyboxMaterial {
    /// Creates a new skybox material with color set to white and no texture.
    fn default() -> Self {
        Self {
            // Set the default color to white, so when using with a texture the color doesn't impact
            // the texture color.
            color: Color::WHITE,
            texture: None,
        }
    }
}

/// Resource to help with converting skyboxes stored as vertically stacked images as described in
/// the [crate] documentation into array textures in the correct format for use in a
/// [`SkyboxMaterial`].
///
/// The [`SkyboxPlugin`] will add this resource and install an associated system which handles the
/// actual texture conversion. Conversion is performed using
/// [`Texture::reinterpret_stacked_2d_as_array`]. If you prefer, you are free to handle converting
/// textures yourself, or use a texture format + loader which can load array textures directly.
#[derive(Default)]
pub struct SkyboxTextureConversion {
    /// List of texture handles that should be skyboxes.
    handles: Vec<Handle<Texture>>,
}

impl SkyboxTextureConversion {
    /// Takes a handle to a texture whose dimensions are `N` wide by `6*N` high, waits for it to load,
    /// and then reinterprets that texture as an array of 6 textures suitable or a skybox. This is
    /// useful if your skybox texture is not in a format that has layers. This should only be done
    /// once per testure, and will panic if the texture has already be reinterpreted.
    pub fn make_array(&mut self, handle: Handle<Texture>) {
        self.handles.push(handle);
    }
}

/// System to handle reinterpreting an Nx6N vertical texture stack as an array of textures suitable
/// for a skybox.
fn convert_skyboxes(
    mut conversions: ResMut<SkyboxTextureConversion>,
    mut textures: ResMut<Assets<Texture>>,
) {
    let mut i = 0;
    loop {
        // Check each texture in the pending queue to see if it is loaded yet.
        let (handle, texture) = match conversions.handles.get(i) {
            Some(handle) => match textures.get_mut(handle) {
                // If it's loaded, take it out of the queue.
                Some(texture) => (conversions.handles.remove(i), texture),
                None => {
                    i += 1;
                    continue;
                }
            },
            None => break,
        };

        debug!(
            "Reinterpreting as Skybox Texture {:?}: format: {:?}, len: {}, extents: {:?}",
            handle,
            texture.format,
            texture.data.len(),
            texture.size
        );
        texture.reinterpret_stacked_2d_as_array(6);
    }
}

/// Constants defining node names in the render graph.
pub mod node {
    /// Node for the `SkyboxMaterial`.
    pub const SKYBOX_MATERIAL: &str = "skybox_material";
}

/// Add the render graph and pipeline for the skybox to the world.
fn add_skybox_graph(world: &mut World) {
    {
        let mut graph = world.get_resource_mut::<RenderGraph>().unwrap();
        graph.add_system_node(
            node::SKYBOX_MATERIAL,
            AssetRenderResourcesNode::<SkyboxMaterial>::new(true),
        );
        graph
            .add_node_edge(node::SKYBOX_MATERIAL, base::node::MAIN_PASS)
            .unwrap();
    }

    let pipeline = SkyboxPipeline::specialize(&mut world.get_resource_mut::<Assets<Shader>>().unwrap());
    let mut pipelines = world
        .get_resource_mut::<Assets<PipelineDescriptor>>()
        .unwrap();
    pipelines.set_untracked(SKYBOX_PIPELINE_HANDLE, pipeline);
}

/// Handle to use to reference the skybox pipeline.
pub const SKYBOX_PIPELINE_HANDLE: HandleUntyped =
    HandleUntyped::weak_from_u64(PipelineDescriptor::TYPE_UUID, 16037920303847147810);

fn add_skybox_mesh(meshes: &mut Assets<Mesh>) {
    // Skybox mesh needs to be large enough not to get caught in the camera's near-clip plane (but
    // can otherwise be any value).
    meshes.set_untracked(SKYBOX_MESH_HANDLE, Mesh::from(shape::Cube { size: 1.0 }));
}

pub const SKYBOX_SHADER_HANDLE: HandleUntyped =
    HandleUntyped::weak_from_u64(Shader::TYPE_UUID, 13012847047122779583);

#[derive(Resource)]
pub struct SkyboxPipeline {
    pub view_layout: BindGroupLayout,
    pub image_layout: BindGroupLayout,
}

impl FromWorld for SkyboxPipeline {
    fn from_world(world: &mut World) -> Self {
        let render_device = world.resource::<RenderDevice>();

        let view_layout = render_device.create_bind_group_layout(&BindGroupLayoutDescriptor {
            entries: &[BindGroupLayoutEntry {
                binding: 0,
                visibility: ShaderStages::VERTEX | ShaderStages::FRAGMENT,
                ty: BindingType::Buffer {
                    ty: BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: Some(ViewUniform::min_size()),
                },
                count: None,
            }],
            label: Some("skybox_view_layout"),
        });

        let image_layout = render_device.create_bind_group_layout(&BindGroupLayoutDescriptor {
            entries: &[
                BindGroupLayoutEntry {
                    binding: 0,
                    visibility: ShaderStages::FRAGMENT,
                    ty: BindingType::Texture {
                        multisampled: false,
                        sample_type: TextureSampleType::Float { filterable: true },
                        view_dimension: TextureViewDimension::Cube,
                    },
                    count: None,
                },
                BindGroupLayoutEntry {
                    binding: 1,
                    visibility: ShaderStages::FRAGMENT,
                    ty: BindingType::Sampler(SamplerBindingType::Filtering),
                    count: None,
                },
            ],
            label: Some("skybox_image_layout"),
        });

        SkyboxPipeline {
            view_layout,
            image_layout,
        }
    }
}

#[derive(Clone, Copy, Hash, PartialEq, Eq)]
pub struct SkyboxPipelineKey {}

impl SpecializedRenderPipeline for SkyboxPipeline {
    type Key = SkyboxPipelineKey;

    fn specialize(&self, key: Self::Key) -> RenderPipelineDescriptor {
        let shader_defs = Vec::new();

        RenderPipelineDescriptor {
            vertex: VertexState {
                shader: super::SKYBOX_SHADER_HANDLE.typed::<Shader>(),
                entry_point: "vertex".into(),
                shader_defs: shader_defs.clone(),
                buffers: vec![],
            },
            fragment: Some(FragmentState {
                shader: super::SKYBOX_SHADER_HANDLE.typed::<Shader>(),
                shader_defs,
                entry_point: "fragment".into(),
                targets: vec![Some(ColorTargetState {
                    format: TextureFormat::bevy_default(),
                    blend: Some(BlendState::ALPHA_BLENDING),
                    write_mask: ColorWrites::ALL,
                })],
            }),
            layout: Some(vec![self.view_layout.clone(), self.image_layout.clone()]),
            primitive: PrimitiveState {
                front_face: FrontFace::Ccw,
                cull_mode: CullMode::Front,
                unclipped_depth: false,
                polygon_mode: PolygonMode::Fill,
                conservative: false,
                topology: PrimitiveTopology::TriangleList,
                strip_index_format: None,
            },
            depth_stencil: Some(DepthStencilState {
                format: TextureFormat::Depth32Float,
                depth_write_enabled: true,
                // Depth test needs to use LessEqual because it is forcing all points of the skybox to
                // maximum depth.
                depth_compare: CompareFunction::LessEqual,
                stencil: StencilState {
                    front: StencilFaceState::IGNORE,
                    back: StencilFaceState::IGNORE,
                    read_mask: 0,
                    write_mask: 0,
                },
                bias: DepthBiasState {
                    constant: 0,
                    slope_scale: 0.0,
                    clamp: 0.0,
                },
            }),
            multisample: MultisampleState {
                count: 1,
                mask: !0,
                alpha_to_coverage_enabled: false,
            },
            label: Some("skybox_pipeline".into()),
        }
    }
}
